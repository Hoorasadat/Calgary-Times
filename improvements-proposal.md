# Question 1:
I will setup a state for blogs using useState hook in BlogList function component. Then, I will add a useEffect function inside this component to fetch data and add an empty array as its dependency since it is required to get run everytime the BlogList gets run. In useEffect, I will add a fetch API inside an async await function to get the data and then, I will update the blogs state. Since fetching data is a side effect opperation and can affect other components and can't be done during rendering, the best practice is using useEffect. It serves the same purpose as componentDidMount in React classes but unified into a single API and it gets run automatically everytime the function BlogList gets run. We can also extract fetching and useEffect into a useData hook.
Because the fetchhing might takes time, for a better user experience, I will add a "Loading" header to the return part of the function for the cases that the lenght of the blogs array is zero.
I will also add an ErrorBoundry component to manage the possible error in fetching the data and show the user a proper message.
For large number of data fetching from an API, the first thing that might come to mind is to cache data for future usage, which means that the first load only can take long time and after that each load will be from cache.

# Question 2:
It is not good to use nanoid, or any other random ID generator, to create keys for a React array elements. In fact, it says, right on their README, that "Thereâ€™s currently no correct way to use nanoid for React key prop since it should be consistent among renders" (https://github.com/ai/nanoid/blob/main/README.md). Using a random generator for keys forces the reconciliation process to always view every element in the array as "new" or "changed", which forces it to rerender - and that can cause some nasty side effects.
There are many ways in which we can create unique keys, the simplest method is to use the index when iterating arrays i.e. paginationRange.map((pageNumber, index). Then we can use "index" as the key for each pageNumber i.e. key={index}.
